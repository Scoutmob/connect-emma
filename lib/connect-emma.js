// Generated by CoffeeScript 1.3.3
(function() {
  var Processor, Route, gm, http, https, path, url;

  http = require('http');

  https = require('https');

  url = require('url');

  path = require('path');

  gm = require('gm');

  Route = (function() {

    function Route(pathname) {
      var ext, lastPathComponent;
      this.pathComponents = pathname.split('/');
      if (this.pathComponents[0] === '') {
        this.pathComponents.shift();
      }
      this.namespace = this.pathComponents.shift();
      lastPathComponent = this.pathComponents.pop();
      ext = path.extname(lastPathComponent);
      this.pathComponents.push(path.basename(lastPathComponent, ext));
      this.extension = ext.substring(1, ext.length);
    }

    return Route;

  })();

  Processor = (function() {

    function Processor(ns, request, response) {
      this.ns = ns;
      this.request = request;
      this.response = response;
    }

    Processor.prototype.fetch = function(urlString) {
      try {
        return this.doFetch(urlString);
      } catch (err) {
        console.log("[ERR] error fetching image: " + err.message);
        return this.failWithError(err);
      }
    };

    Processor.prototype.doFetch = function(urlString) {
      var protocol,
        _this = this;
      protocol = 0 === urlString.indexOf('https') ? https : http;
      return protocol.get(url.parse(urlString), function(imageResponse) {
        try {
          if (imageResponse.statusCode === 200) {
            return _this.processImage(imageResponse, urlString);
          } else {
            return _this.sendSourceError(imageResponse);
          }
        } catch (err) {
          console.log("[ERR] error serving image: " + err.message);
          return _this.failWithError(err);
        }
      }).on('error', function(err) {
        console.log("[ERR] error fetching image: " + err.message);
        return _this.failWithError(err);
      }).on('close', function() {
        console.log("[ERR] connection closed");
        return _this.fail(500, 'Connection closed');
      }).on('socket', function(socket) {
        if (_this.ns.timeout != null) {
          return socket.setTimeout(_this.ns.timeout);
        }
      });
    };

    Processor.prototype.processImage = function(imageData, imageURL) {
      var image,
        _this = this;
      image = gm(imageData, path.basename(imageURL));
      this.ns.processImage(image, this.request);
      return image.stream(function(err, stdout, stderr) {
        var headers;
        if (err) {
          console.log("[ERR] error processing image: " + err.message);
          return _this.failWithError(err);
        } else {
          headers = {
            'Date': new Date().toUTCString(),
            'Content-Type': imageData.headers['content-type'],
            'Last-Modified': imageData.headers['last-modified']
          };
          if (_this.ns.cacheExpiration != null) {
            headers['Expires'] = new Date(new Date().getTime() + (_this.ns.cacheExpiration * 1000)).toUTCString();
          }
          _this.response.writeHead(imageData.statusCode, headers);
          return stdout.pipe(_this.response);
        }
      });
    };

    Processor.prototype.sendSourceError = function(sourceResponse) {
      var headers;
      headers = {
        'Date': new Date().toUTCString(),
        'Content-Type': sourceResponse.headers['content-type'],
        'Cache-Control': 'no-cache'
      };
      this.response.writeHead(sourceResponse.statusCode, headers);
      return sourceResponse.pipe(this.response);
    };

    Processor.prototype.failWithError = function(err) {
      return this.fail(500, err.message);
    };

    Processor.prototype.fail = function(statusCode, message) {
      this.response.writeHead(statusCode, {
        'Date': new Date().toUTCString(),
        'Content-Type': 'text/plain',
        'Cache-Control': 'no-cache'
      });
      return this.response.end(message);
    };

    return Processor;

  })();

  module.exports = function(options) {
    return function(req, res, next) {
      var comp, i, ns, route, targetURL, _i, _len, _ref;
      route = new Route(url.parse(req.url).pathname);
      if (ns = options.namespaces[route.namespace]) {
        targetURL = ns.urlTemplate;
        _ref = route.pathComponents;
        for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
          comp = _ref[i];
          targetURL = targetURL.replace(new RegExp("\\$" + (i + 1), 'g'), comp);
        }
        targetURL = targetURL.replace(/\$extension/g, route.extension);
        return new Processor(ns, req, res).fetch(targetURL);
      } else {
        return next();
      }
    };
  };

}).call(this);
